/*
 * linux/drivers/thermal/cpu_hotplug_cooling.c
 *
 * Copyright 2015 Amazon.com, Inc. or its Affiliates. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 */

#include <linux/device.h>
#include <linux/module.h>
#include <linux/thermal.h>
#include <linux/uaccess.h>
#include <linux/thermal.h>
#include <linux/err.h>
#include <linux/slab.h>
#include <linux/cpu.h>

#include <linux/cpu_hotplug_cooling.h>

#define CPU_MAX_STATE 1

static DEFINE_IDR(cpu_hotplug_idr);
static DEFINE_MUTEX(cooling_cpu_hotplug_lock);

/**
 * struct cpu_hotplug_cooling_device - data for cooling device with cpu_hotplug
 * @id: unique integer value corresponding to each cpu_hotplug_cooling_device
 *      registered.
 * @cpu: unique integer value corresponding to each cpu_hotplug_cooling_device
 *	registered.
 * @cool_dev: thermal_cooling_device pointer to keep track of the
 *	registered cooling device.
 * @cpu_hotplug_state: integer value representing the current state of cpu_hotplug
 *	cooling	devices.
 *
 * This structure is required for keeping information of each
 * cpu_hotplug_cooling_device registered. In order to prevent corruption of this a
 * mutex lock cooling_cpu_hotplug_lock is used.
 */
struct cpu_hotplug_cooling_device {
	int id;
	unsigned long cpu;
	struct thermal_cooling_device *cool_dev;
	unsigned long cpu_hotplug_state;
	struct notifier_block nb;
};

/**
 * get_idr - function to get a unique id.
 * @idr: struct idr * handle used to create a id.
 * @id: int * value generated by this function.
 *
 * This function will populate @id with an unique
 * id, using the idr API.
 *
 * Return: 0 on success, an error code on failure.
 */
static int get_idr(struct idr *idr, int *id)
{
	int ret;

	mutex_lock(&cooling_cpu_hotplug_lock);
	ret = idr_alloc(idr, NULL, 0, 0, GFP_KERNEL);
	mutex_unlock(&cooling_cpu_hotplug_lock);
	if (unlikely(ret < 0))
		return ret;
	*id = ret;

	return 0;
}

/**
 * release_idr - function to free the unique id.
 * @idr: struct idr * handle used for creating the id.
 * @id: int value representing the unique id.
 */
static void release_idr(struct idr *idr, int id)
{
	mutex_lock(&cooling_cpu_hotplug_lock);
	idr_remove(idr, id);
	mutex_unlock(&cooling_cpu_hotplug_lock);
}

/**
 * cpu_hotplug_apply_cooling - function to apply frequency clipping.
 * @cpu_hotplug_device: cpu_hotplug_cooling_device pointer containing frequency
 *	clipping data.
 * @cooling_state: value of the cooling state.
 *
 * Function used to make sure the cpu_hotplug layer is aware of current thermal
 * limits. The limits are applied by updating the cpu_hotplug policy.
 *
 * Return: 0 on success, an error code otherwise (-EINVAL in case wrong
 * cooling state).
 */
static int cpu_hotplug_apply_cooling(struct cpu_hotplug_cooling_device *cpu_hotplug_device,
				     unsigned long cooling_state)
{
	/* Check if the old cooling action is same as new cooling action */
	if (cpu_hotplug_device->cpu_hotplug_state == cooling_state)
		return 0;
	cpu_hotplug_device->cpu_hotplug_state = cooling_state;

	if (!cpu_online(cpu_hotplug_device->cpu))
		return 0;

	cpu_down(cpu_hotplug_device->cpu);

	return 0;
}

/**
 * cpu_hotplug_thermal_notifier - notifier callback for cpu_hotplug policy change.
 * @nb:	struct notifier_block * with callback info.
 * @action: value showing cpu_hotplug event for which this function invoked.
 * @hcpu: callback-specific data
 *
 * Callback to highjack the notification on cpu_hotplug policy transition.
 * Every time there is a change in policy, we will intercept and
 * update the cpu_hotplug policy with thermal constraints.
 *
 * Return: 0 (success)
 */
static int cpu_hotplug_thermal_notifier(struct notifier_block *nb,
					unsigned long action,
					void *hcpu)
{
	unsigned long cpu = (unsigned long)hcpu;
	struct cpu_hotplug_cooling_device *cpu_hotplug_device;
	unsigned long state = 0;

	cpu_hotplug_device = container_of(nb, struct cpu_hotplug_cooling_device, nb);
	state = cpu_hotplug_device->cpu_hotplug_state;

	if (cpu != cpu_hotplug_device->cpu)
		return NOTIFY_OK;

	switch (action) {
	case CPU_UP_PREPARE:
	case CPU_UP_PREPARE_FROZEN:
		if (state)
			return NOTIFY_BAD;
		break;
	default:
		break;
	}
	return NOTIFY_OK;
}

/* cpu_hotplug cooling device callback functions are defined below */
/**
 * cpu_hotplug_get_max_state - callback function to get the max cooling state.
 * @cdev: thermal cooling device pointer.
 * @state: fill this variable with the max cooling state.
 *
 * Callback for the thermal cooling device to return the cpu_hotplug
 * max cooling state.
 *
 * Return: 0 on success, an error code otherwise.
 */
static int cpu_hotplug_get_max_state(struct thermal_cooling_device *cdev,
				     unsigned long *state)
{
	*state =  CPU_MAX_STATE;
	return 0;
}

/**
 * cpu_hotplug_get_cur_state - callback function to get the current cooling state.
 * @cdev: thermal cooling device pointer.
 * @state: fill this variable with the current cooling state.
 *
 * Callback for the thermal cooling device to return the cpu_hotplug
 * current cooling state.
 *
 * Return: 0 on success, an error code otherwise.
 */
static int cpu_hotplug_get_cur_state(struct thermal_cooling_device *cdev,
				 unsigned long *state)
{
	struct cpu_hotplug_cooling_device *cpu_hotplug_device = cdev->devdata;

	*state = cpu_hotplug_device->cpu_hotplug_state;

	return 0;
}

/**
 * cpu_hotplug_set_cur_state - callback function to set the current cooling state.
 * @cdev: thermal cooling device pointer.
 * @state: set this variable to the current cooling state.
 *
 * Callback for the thermal cooling device to change the cpu_hotplug
 * current cooling state.
 *
 * Return: 0 on success, an error code otherwise.
 */
static int cpu_hotplug_set_cur_state(struct thermal_cooling_device *cdev,
				 unsigned long state)
{
	struct cpu_hotplug_cooling_device *cpu_hotplug_device = cdev->devdata;

	return cpu_hotplug_apply_cooling(cpu_hotplug_device, state);
}

/* Bind cpu_hotplug callbacks to thermal cooling device ops */
static struct thermal_cooling_device_ops const cpu_hotplug_cooling_ops = {
	.get_max_state = cpu_hotplug_get_max_state,
	.get_cur_state = cpu_hotplug_get_cur_state,
	.set_cur_state = cpu_hotplug_set_cur_state,
};

/**
 * cpu_hotplug_cooling_register - function to create cpu_hotplug cooling device.
 *
 * This interface function registers the cpu_hotplug cooling device with the name
 * "thermal-cpu_hotplug-%x". This api can support multiple instances of cpu_hotplug
 * cooling devices.
 *
 * Return: a valid struct thermal_cooling_device pointer on success,
 * on failure, it returns a corresponding ERR_PTR().
 */
struct thermal_cooling_device *cpu_hotplug_cooling_register(unsigned int cpu)
{
	struct thermal_cooling_device *cool_dev;
	struct cpu_hotplug_cooling_device *cpu_hotplug_dev = NULL;
	char dev_name[THERMAL_NAME_LENGTH];
	int ret = 0;

	cpu_hotplug_dev = kzalloc(sizeof(struct cpu_hotplug_cooling_device),
				  GFP_KERNEL);
	if (!cpu_hotplug_dev)
		return ERR_PTR(-ENOMEM);

	cpu_hotplug_dev->cpu =  (unsigned long)cpu;

	ret = get_idr(&cpu_hotplug_idr, &cpu_hotplug_dev->id);
	if (ret) {
		kfree(cpu_hotplug_dev);
		return ERR_PTR(-EINVAL);
	}

	snprintf(dev_name,
		 sizeof(dev_name),
		 "thermal-cpu%d-hp-%d",
		 cpu,
		 cpu_hotplug_dev->id);

	cool_dev = thermal_cooling_device_register(dev_name,
						   cpu_hotplug_dev,
						   &cpu_hotplug_cooling_ops);
	if (!cool_dev) {
		kfree(cpu_hotplug_dev);
		return ERR_PTR(-EINVAL);
	}

	cpu_hotplug_dev->cool_dev = cool_dev;
	cpu_hotplug_dev->cpu_hotplug_state = 0;

	mutex_lock(&cooling_cpu_hotplug_lock);

	cpu_hotplug_dev->nb.notifier_call = cpu_hotplug_thermal_notifier;
	register_cpu_notifier(&cpu_hotplug_dev->nb);

	mutex_unlock(&cooling_cpu_hotplug_lock);

	return cool_dev;
}
EXPORT_SYMBOL_GPL(cpu_hotplug_cooling_register);

/**
 * cpu_hotplug_cooling_unregister - function to remove cpu_hotplug cooling device.
 * @cdev: thermal cooling device pointer.
 *
 * This interface function unregisters the "thermal-cpu_hotplug-%x" cooling device.
 */
void cpu_hotplug_cooling_unregister(struct thermal_cooling_device *cdev)
{
	struct cpu_hotplug_cooling_device *cpu_hotplug_dev = cdev->devdata;

	mutex_lock(&cooling_cpu_hotplug_lock);
	unregister_cpu_notifier(&cpu_hotplug_dev->nb);
	mutex_unlock(&cooling_cpu_hotplug_lock);

	thermal_cooling_device_unregister(cpu_hotplug_dev->cool_dev);
	release_idr(&cpu_hotplug_idr, cpu_hotplug_dev->id);
	kfree(cpu_hotplug_dev);
}
EXPORT_SYMBOL_GPL(cpu_hotplug_cooling_unregister);
